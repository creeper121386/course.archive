## exp2
- 任务: 建立符号表 & 报语义错误.
- 各种结构定义: def.h
- 程序入口: parser.y中,根节点调用sematic_analyze()
- 符号表:全局只有一个表,不同作用域下,指定不同的起始位置来进行管理.
- 要怎么做: 遍历ast,访问到声明部分的结点时，在符号表中添加新的内容；访问到执行语句部分时，根据访问的变量（或函数）名称查询符号表，并分析其静态语义的正确性。
- 不同作用域的处理: 
    - LEV(层号)表示不同作用域,每次遇到一个复合语句的结点COM_STM，首先对LEV加1,并使用栈symbol_scope_TX，记录该作用域变量在符号表中的起点位置，即将符号表symbolTable的栈顶位置symbolTable.index保存在栈symbol_scope_TX中。
    - 每次要登记一个新的符号到符号表中时，首先在symbolTable中，从栈顶向栈底方向查层号为LEV的符号，是否有和当前待登记的符号重名，是则报重复定义错误，否则使用LEV作为层号将新的符号登记到符号表中。
    - 每次遍历完一个复合语句结点COM_STM的所有子树，准备回到其父结点时，这时该复合语句语义分析完成，需要从符号表中删除该复合语句的变量，方法是首先symbol_scope_TX进行出栈操作，取出该复合语句作用域的起点，再根据这个值修改symbolTable.index，同时LEV减一，很简单地完成了符号表的符号删除操作。
- 填充正确的符号类型:(int, float, char...):在vardec节点,把左孩子的type赋值给右孩子

实现:
（1）使用未定义的变量；
（2）调用未定义或未声明的函数；
（3）在同一作用域，名称的重复定义（如变量名、函数名、结构类型名以及结构体成员名等）。为更清楚说明语义错误，这里也可以拆分成几种类型的错误，如变量重复定义、函数重复定义、结构体成员名重复等；
（4）对非函数名采用函数调用形式；
（5）对函数名采用非函数调用形式访问；
（6）函数调用时参数个数不匹配，如实参表达式个数太多、或实参表达式个数太少；
（7）函数调用时实参和形参类型不匹配；
（8）对非数组变量采用下标变量的形式访问；
（9）数组变量的下标不是整型表达式；
（10）对非结构变量采用成员选择运算符“.”；
（11）条件表达式类型错误
（12）赋值号左边不是左值表达式；
（13）对非左值表达式进行自增、自减运算；
（14）对结构体变量进行自增、自减运算；
（15）类型不匹配。如数组名与结构变量名间的运算，需要指出类型不匹配错误；有些需要根据定义的语言的语义自行进行界定，比如：32+'A'，10*12.3，如果使用强类型规则，则需要报错，如果按C语言的弱类型规则，则是允许这类运算的，但需要在后续阶段需要进行类型转换，类型统一后再进行对应运算；
（16）函数返回值类型与函数定义的返回值类型不匹配；
（17）函数没有返回语句（当函数返回值类型不是void时）；
（18）break语句不在循环语句或switch语句中；
（19）continue语句不在循环语句中；
(20) 数学表达式类型错误(例如对string做数学运算)
(21) 自增,自减类型错误
    

